<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name="hugo-theme" content="Axiom 0.7.2">



  <link rel="icon" type="image/png" sizes="32x32" href="https://julhe.github.io/">
  <link rel="icon" type="image/x-icon" href="https://julhe.github.io/">
  <link rel="apple-touch-icon" href="https://julhe.github.io/">
  <link rel="canonical" href="https://julhe.github.io/posts/how_not_to_optimize_shaders/">
<link rel="preload" as="style" href="https://julhe.github.io/bundle.css?v=1708376611" media="all">
<link rel="stylesheet" href="https://julhe.github.io/bundle.css?v=1708376611" media="all">
<style>.cdata pre{color:#edf2f7;background-color:#2d3748}.cdata :not(pre)>code{color:#805ad5;background-color:#f7fafc}.chroma .err{color:#fed7d7;background-color:#9b2c2c}.chroma .hl{background-color:#4a5568}.chroma .ln{color:#a0aec0}.chroma .k,.chroma .kc,.chroma .kd,.chroma .kn,.chroma .kp,.chroma .kr{color:#63b3ed}.chroma .kt{color:#b794f4}.chroma .na{color:#f6e05e}.chroma .nb{color:#f6ad55}.chroma .nc{color:#fc8181}.chroma .no{color:#68d391}.chroma .nd{color:#fc8181}.chroma .ne{color:#fc8181}.chroma .nf{color:#f6ad55}.chroma .nt{color:#fc8181}.chroma .l{color:#b794f4}.chroma .dl,.chroma .ld,.chroma .s,.chroma .s2,.chroma .sa,.chroma .sb,.chroma .sc,.chroma .sd{color:#68d391}.chroma .se{color:#a0aec0}.chroma .s1,.chroma .sh,.chroma .si,.chroma .sr,.chroma .ss,.chroma .sx{color:#68d391}.chroma .il,.chroma .m,.chroma .mb,.chroma .mf,.chroma .mh,.chroma .mi,.chroma .mo{color:#b794f4}.chroma .o,.chroma .ow{color:#90cdf4}.chroma .p{color:#cbd5e0}.chroma .c,.chroma .c1,.chroma .ch,.chroma .cm,.chroma .cp,.chroma .cpf,.chroma .cs{color:#a0aec0}.chroma .ge{font-style:italic}.chroma .gs{font-weight:700}
</style>

<link rel="preload" as="image" href="https://julhe.github.io/posts/how_not_to_optimize_shaders/thumb.jpg">

<title>How (Not) To Optimize Shaders : julhe.github.io</title>

<meta property="og:title" content="How (Not) To Optimize Shaders">
<meta property="og:site_name" content="julhe.github.io">
<meta property="og:url" content="https://julhe.github.io/posts/how_not_to_optimize_shaders/">
<link rel="image_src" href="https://julhe.github.io/posts/how_not_to_optimize_shaders/thumb.jpg">
<meta property="og:image" content="https://julhe.github.io/posts/how_not_to_optimize_shaders/thumb.jpg">
<meta property="og:image:width" content="">
<meta property="og:image:height" content="">
<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:description" content="Motivation I recently started working on the public release of an effect I did for Misgiven. The shader does render fake volumetric lights, also known as god rays or crepuscular rays. The effect is cheap and effective in creating the illusion of volumetric lights. While the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance.">
<meta name="description" content="Motivation I recently started working on the public release of an effect I did for Misgiven. The shader does render fake volumetric lights, also known as god rays or crepuscular rays. The effect is cheap and effective in creating the illusion of volumetric lights. While the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance.">
<meta property="og:updated_time" content="2024-02-18T22:00:00Z">
<meta property="fb:app_id" content="">
<meta name="author" content="Unknown">
<meta property="article:author" content="https://julhe.github.io/">
<meta property="article:published_time" content="2024-02-18T22:00:00Z">
<meta property="article:modified_time" content="2024-02-18T22:00:00Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "How (Not) To Optimize Shaders",
  "alternativeHeadline": "Motivation I recently started working on the public release of an effect I did for Misgiven. The shader does render fake volumetric lights, also known as god rays or crepuscular rays. The effect is cheap and effective in creating the illusion of volumetric lights. While the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance.",
  "url": "https://julhe.github.io/posts/how_not_to_optimize_shaders/",
  "image": "https://julhe.github.io/posts/how_not_to_optimize_shaders/thumb.jpg",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://julhe.github.io/posts/how_not_to_optimize_shaders/"
  },
  "description": "Motivation I recently started working on the public release of an effect I did for Misgiven. The shader does render fake volumetric lights, also known as god rays or crepuscular rays. The effect is cheap and effective in creating the illusion of volumetric lights. While the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance.",
  "author": {
    "@type": "Person",
    "name": "Unknown"
  },
  "publisher": {
    "@type": "Organization",
    "name": "julhe.github.io",
    "logo": {
      "@type": "ImageObject",
      "url": "https://julhe.github.io/"
    }
  },
  "datePublished": "2024-02-18T22:00:00Z",
  "dateModified": "2024-02-18T22:00:00Z",
  "articleBody": "\u003ch1 id=\"motivation\"\u003eMotivation\u003c/h1\u003e\n\u003cp\u003eI recently started working on the public release of an effect I did for \u003ca href=\"https://store.steampowered.com/app/2475620/Misgiven/\"\u003eMisgiven\u003c/a\u003e. The shader does render fake volumetric lights, also known as god rays or crepuscular rays.\u003c/p\u003e\n\u003cp\u003eThe effect is cheap and effective in creating the illusion of volumetric lights.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"Screenshot_BeforeAfter_2.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eWhile the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance. (In this article however, I will only look into the graphics-programmer side of things.)\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eShameless self-promotion: You can find the release + demo down below on itch.io\u003c/em\u003e\u003c/p\u003e\n\u003ciframe frameborder=\"0\" src=\"https://itch.io/embed/2419069?border_width=5\" width=\"560\" height=\"175\"\u003e\u003ca href=\"https://symmetrybreak.itch.io/ssgr-demo\"\u003eScreen Space God Rays by Symmetry Break Studio\u003c/a\u003e\u003c/iframe\u003e\r\n\u003ch2 id=\"the-god-ray-shader\"\u003eThe God Ray Shader\u003c/h2\u003e\n\u003cp\u003eThe full asset consisted of multiple shaders for masking, composing, etc. The most interesting shader is, of course, the one that creates the actual god rays. It\u0026rsquo;s basically done with two ingredients: zoom blur and disk blur.\u003c/p\u003e\n\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/dt3BR4?gui=true\u0026t=10\u0026paused=true\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e\r\n\u003ch3 id=\"zoom-blur\"\u003eZoom Blur\u003c/h3\u003e\n\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/XXS3Wz?gui=true\u0026t=10\u0026paused=true\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e\r\n\u003cp\u003eZoom blur looks similar to what would happen if you took a photo with a long exposure while changing the zoom factor. In the case of the god ray shader, it is the most important ingredient.\u003c/p\u003e\n\u003cp\u003eMask out a portion of the image, mostly the larger area where the light is emitted from, apply zoom blur to it, and blend it back to the original image. Voil√†, you\u0026rsquo;ve created the illusion of light beams. Calculating the samples for this effect is not very expensive on its own.\u003c/p\u003e\n\u003ch3 id=\"disk-blur-using-the-vogel-disk-sample-pattern\"\u003eDisk Blur (Using The Vogel Disk Sample Pattern)\u003c/h3\u003e\n\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/X3B3Wz?gui=true\u0026t=10\u0026paused=true\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e\r\n\u003cp\u003eThe Vogel disk is a pleasant-looking procedural pattern that looks similar to a sunflower. It can be used to blur an image with a circle-like shape, by sampling the image multiple times and averaging the result. Each time we sample, we use a different position on the Vogel disk. This shadertoy demonstrates the look of this pattern.\u003c/p\u003e\n\u003c!-- \u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/4l3yRM?gui=true\u0026t=10\u0026paused=false\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e --\u003e\r\n\u003cp\u003eFor the god ray shader, I use it to make the light beams appear softer, which I find very visually pleasing.\u003c/p\u003e\n\u003ch1 id=\"paths-for-optimization\"\u003ePaths For Optimization\u003c/h1\u003e\n\u003cp\u003eUpon reviewing the code, I finally had the time to address a concern I had with the original code:\u003c/p\u003e\n\u003cp\u003eShould I pre-compute all the sample positions on the CPU or compute them on the fly?\u003c/p\u003e\n\u003cp\u003eAfter all, computing the Vogel disk uses  \u003ccode\u003esin()\u003c/code\u003e, \u003ccode\u003ecos()\u003c/code\u003e and \u003ccode\u003esqrt()\u003c/code\u003e. These functions are notorious for being slow, or, to be more specific, running over multiple clock cycles.\u003c/p\u003e\n\u003cp\u003eBelow are two variants I\u0026rsquo;ve tested:\u003c/p\u003e\n\u003ch2 id=\"1-on-the-fly\"\u003e#1 On-The-Fly\u003c/h2\u003e\n\u003cp\u003eThe Vogel disk and zoom blur positions are calculated on-the-fly.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e VogelDiskSample(\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e sampleIndex, \u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e sampleCount, \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e phi)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e sampleIndexf \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e(sampleIndex);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e sampleCountf \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e(sampleCount);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e goldenAngle \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e2.39996\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e r \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e sqrt((sampleIndexf \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0.5\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e/\u003c/span\u003e sampleCountf);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e theta \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e sampleIndexf \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e goldenAngle \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e phi;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e(cos(theta), sin(theta)) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e r;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003evec4\u003c/span\u003e fragment_shader() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e softnessSmpIdx \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; softnessSmpIdx \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e softnessSmpCount; softnessSmpIdx\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#6272a4\"\u003e// Compute the sample on-the-fly\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e sample \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e VogelDiskSample(softnessSmpIdx, softnessSmpCount, \u003cspan style=\"color:#bd93f9\"\u003e0.0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e blurRadius;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e radialIdx \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; radialIdx \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e radialSmpCount; radialIdx\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#6272a4\"\u003e// Compute the radial blur on-the-fly\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e stepSize \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e radialIdx \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e rangePerSample;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e uv \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e uvCentered \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e (\u003cspan style=\"color:#bd93f9\"\u003e1.0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e stepSize) \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e uvOffset ;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            buffer \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003e texture(iChannel0, uv); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-pre-computed\"\u003e#2 Pre-Computed\u003c/h2\u003e\n\u003cp\u003eThe Vogel disk and the zoom blur positions are pre-calculated on the CPU.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUsing pre-computed data is also called a Look-Up-Table or LUT.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003evec4\u003c/span\u003e fragment_shader() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e smpIndex \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; smpIndex \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e sampleCount; smpIndex\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#6272a4\"\u003e// Both Vogel and radial are pre-computed.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003evec4\u003c/span\u003e sampleTS \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e sampleLut[smpIndex];\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e uvCentered \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e screenUv \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e sampleTS.zw;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e uv \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e uvCentered \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e sampleTS.xy \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e sampleTS.zw;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        buffer \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003e  texture(iChannel0, uv);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eJust from looking at the size of the code, the pre-computed version should run faster, because more code = more work, right?\u003c/p\u003e\n\u003cp\u003eEven when looking at the amount of assembler instructions (in DXBC), the same picture forms:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOn-The-Fly: 46 instructions\u003c/li\u003e\n\u003cli\u003ePre-Computed: 26 instructions (-56%)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut after all, we can\u0026rsquo;t be certain, so let\u0026rsquo;s run some benchmarks.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eGTX 1050 Ti - 1/3\u003c/th\u003e\n\u003cth\u003eRTX 4070 - 1/3 Resolution\u003c/th\u003e\n\u003cth\u003eRTX 4070 - Full Resolution\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eOn-The-Fly\u003c/td\u003e\n\u003ctd\u003e10.0ms\u003c/td\u003e\n\u003ctd\u003e0.87ms\u003c/td\u003e\n\u003ctd\u003e3.16ms\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePre-Computed\u003c/td\u003e\n\u003ctd\u003e10.3ms (+3%)\u003c/td\u003e\n\u003ctd\u003e0.95ms (+9%)\u003c/td\u003e\n\u003ctd\u003e3.78ms (+16%)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eHuh, what is going on here? Why is the version with \u003cem\u003emore\u003c/em\u003e instructions \u003cem\u003efaster\u003c/em\u003e?\u003c/p\u003e\n\u003ch1 id=\"the-impact-of-memory-latency\"\u003eThe Impact Of Memory Latency\u003c/h1\u003e\n\u003cp\u003eThere is a second and often overlooked factor in performance, not only in the case of shaders, which is memory latency. This refers to the amount of time a processor has to wait to load a value from memory, mostly a significant time.\u003c/p\u003e\n\u003cp\u003eThe on-the-fly method performs faster, because it is not so dependent on memory. It doesn\u0026rsquo;t need to wait for the memory to know where to sample the texture we are trying to blur. It may have even already calculated that, \u003cem\u003ewhile\u003c/em\u003e it was asking the memory to read the texture from a previous iteration of the loop.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eModern GPUs are in fact able to suspend work on a pixel (or any other work item) while waiting for memory. This is called \u003cem\u003elatency hiding\u003c/em\u003e. In our case, the computation of the Vogel disk may be effectively done in parallel, while a thread is waiting for the memory to read the texture. The effectiveness of latency hiding is dependent on the occupancy. For more info, checkout: \u003ca href=\"https://gpuopen.com/learn/occupancy-explained/\"\u003ehttps://gpuopen.com/learn/occupancy-explained/\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSimplified, the on-the-play method may run like this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCompute the value of \u003ccode\u003euv\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eLoad/Sample from \u003ccode\u003eiChannel0\u003c/code\u003e with \u003ccode\u003euv\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWait for memory.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eWrite the resulting pixel to the frame buffer.\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eFor the Pre-Computed method, the picture is different. Since the texture read itself is dependent on some data that is in memory, a thread needs to wait for that data \u003cstrong\u003efirst\u003c/strong\u003e, before asking the memory \u003cstrong\u003ea second time\u003c/strong\u003e for the texture. At worst, no GPU thread is able to do anything, since all of them are waiting for memory.\u003c/p\u003e\n\u003cp\u003eStep-by-step it would roughly look like this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAsk the memory for \u003ccode\u003epreComputedSamplesFromCPU[smpIndex]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWait for memory.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eCompute \u003ccode\u003euv\u003c/code\u003e from the value of \u003ccode\u003esampleTS\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eLoad/Sample from iChannel0 from \u003ccode\u003euv\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWait for memory.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eWrite the resulting pixel to the frame buffer.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eShader optimization may not always be achieved by reducing the amount of bare metal instructions. As demonstrated, having more instructions for the sake of less memory access may actually increase performance. Care must also be taken when memory reads are dependent on each other, as it is the case with pre-computed version mentioned.\u003c/p\u003e\n\u003ch1 id=\"takeaways\"\u003eTakeaways\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eDon\u0026rsquo;t let instruction counts fool you. A lower instructions count doesn\u0026rsquo;t always mean faster execution.\u003c/li\u003e\n\u003cli\u003eIt is possible for code with more instructions to outperform code with fewer instructions, given enough memory usage.\u003c/li\u003e\n\u003cli\u003eUsing LUTs can improve speed, but it can also backfire if the memory look-up is slower than doing the actual calculation.\u003c/li\u003e\n\u003cli\u003eAvoid memory accesses that is dependent on each other.\u003c/li\u003e\n\u003cli\u003eAlways profile. Your intuition may not be correct.üôÇ\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"bonus---hybrid-approach\"\u003eBonus - Hybrid approach\u003c/h3\u003e\n\u003cp\u003eFor the sake of completion, I also tried a hybrid version. Here, only the vogel disk samples are pre-computed.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e// ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e smpIndex \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; smpIndex \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e sampleCount; smpIndex\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// just pre-compute the vogel disk\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e sample \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e vogelDiskSamples[smpIndex] \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e blurRadius;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003eint\u003c/span\u003e radialIdx \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0\u003c/span\u003e; radialIdx \u003cspan style=\"color:#ff79c6\"\u003e\u0026lt;\u003c/span\u003e radialSmpCount; radialIdx\u003cspan style=\"color:#ff79c6\"\u003e++\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e stepSize \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e radialIdx \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e rangePerSample;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e uv \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e uvCentered \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e (\u003cspan style=\"color:#bd93f9\"\u003e1.0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e stepSize) \u003cspan style=\"color:#ff79c6\"\u003e+\u003c/span\u003e uvOffset ;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        buffer \u003cspan style=\"color:#ff79c6\"\u003e+=\u003c/span\u003e texture(iChannel0, uv); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e//...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIt has an instruction count of 36. This version actually did perform better than the On-The-Fly method, but just by around ~2%.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1 id=\"further-reading\"\u003eFurther Reading\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://gpuopen.com/learn/occupancy-explained/\"\u003eGPU Open / Fran√ßois Guthmann - Occupancy explained\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"
}
</script>

<link rel="preload" as="script" href="https://julhe.github.io/bundle.js?v=1708376611">


</head>
<body>

  <header id="nav" class="header">
  <div class="ax-l-i max-w-6xl">
    <div class="ax-logo">
      <a class="block" href="https://julhe.github.io/" title="julhe.github.io"><span class="font-semibold text-raven-900">julhe.github.io</span></a>
    </div>
    <div class="ax-user">
      <a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target="_blank" rel="noopener nofollow" href="https://www.google.com/search?q=site:https%3a%2f%2fjulhe.github.io%2f" title="Search">
        <svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923l-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33 0 0 0 2.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg>

      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://julhe.github.io/about">
        About
      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://julhe.github.io/posts">
        Posts
      </a>
    </div>
  </div>

  
</header>

  <main>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<div class="default-single">
  <div class="ax-title ax-l-o">
    <div class="ax-l-i max-w-680">
      <h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">How (Not) To Optimize Shaders</h1>

      <div class="ax-meta flex items-center mt-5">
        <div class="flex-grow min-w-0">
          <div class="flex items-center">
  <div class="flex-shrink-0">
    
  </div>
  <div class="flex-shrink-0 ml-2 leading-tight font-content-sans">
    <a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target="_blank" rel="noopener nofollow" title="Unknown" href="https://julhe.github.io/">Unknown</a>
    <time class="text-sm text-raven-500" datetime="2024-02-18T22:00:00Z">Feb 18, 2024 11:00PM</time>
  </div>
</div>

        </div>
        <div>
          <div class="flex items-center">
  <a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Twitter" href="https://twitter.com/intent/tweet?text=How%20%28Not%29%20To%20Optimize%20Shaders%20by%20%40%23%20https%3a%2f%2fjulhe.github.io%2fposts%2fhow_not_to_optimize_shaders%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg>
</a>
  <a class="ml-3 flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Facebook" href="https://www.facebook.com/dialog/share?app_id=&display=page&href=https%3a%2f%2fjulhe.github.io%2fposts%2fhow_not_to_optimize_shaders%2f"><svg class="w-6 h-6 fill-current" viewBox="-7 -3.5 39 39" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M30.234 0H1.765C.8.001 0 .79 0 1.766v28.47C.001 31.2.79 32 1.766 32h15.328V19.625h-4.156V14.78h4.156v-3.564c0-4.134 2.523-6.384 6.21-6.384 1.766 0 3.284.13 3.726.2v4.32h-2.543c-2.006 0-2.394.953-2.394 2.352v3.085h4.797l-.625 4.844h-4.172V32h8.14C31.21 32 32 31.2 32 30.234V1.765C32 .8 31.21 0 30.234 0z"/></svg>
</a>
</div>

        </div>
      </div>
    </div>
  </div>
  <div class="ax-feature ax-l-o">
    <div class="ax-l-i max-w-5xl">

<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/how_not_to_optimize_shaders/thumb.jpg"
alt="How (Not) To Optimize Shaders">
</figure>

    </div>
  </div><div class="ax-content ax-l-o">
    <div class="ax-l-i max-w-680">
      <article class="cdata">
<h1 id="motivation">Motivation</h1>
<p>I recently started working on the public release of an effect I did for <a href="https://store.steampowered.com/app/2475620/Misgiven/">Misgiven</a>. The shader does render fake volumetric lights, also known as god rays or crepuscular rays.</p>
<p>The effect is cheap and effective in creating the illusion of volumetric lights.</p>
<p><img src="Screenshot_BeforeAfter_2.jpg" alt=""></p>
<p>While the original code was done in just ~2 days, now I had the time to dig deeper and offer both a better UX and better performance. (In this article however, I will only look into the graphics-programmer side of things.)</p>
<p><em>Shameless self-promotion: You can find the release + demo down below on itch.io</em></p>
<iframe frameborder="0" src="https://itch.io/embed/2419069?border_width=5" width="560" height="175"><a href="https://symmetrybreak.itch.io/ssgr-demo">Screen Space God Rays by Symmetry Break Studio</a></iframe>
<h2 id="the-god-ray-shader">The God Ray Shader</h2>
<p>The full asset consisted of multiple shaders for masking, composing, etc. The most interesting shader is, of course, the one that creates the actual god rays. It&rsquo;s basically done with two ingredients: zoom blur and disk blur.</p>
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/dt3BR4?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
<h3 id="zoom-blur">Zoom Blur</h3>
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/XXS3Wz?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
<p>Zoom blur looks similar to what would happen if you took a photo with a long exposure while changing the zoom factor. In the case of the god ray shader, it is the most important ingredient.</p>
<p>Mask out a portion of the image, mostly the larger area where the light is emitted from, apply zoom blur to it, and blend it back to the original image. Voil√†, you&rsquo;ve created the illusion of light beams. Calculating the samples for this effect is not very expensive on its own.</p>
<h3 id="disk-blur-using-the-vogel-disk-sample-pattern">Disk Blur (Using The Vogel Disk Sample Pattern)</h3>
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/X3B3Wz?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
<p>The Vogel disk is a pleasant-looking procedural pattern that looks similar to a sunflower. It can be used to blur an image with a circle-like shape, by sampling the image multiple times and averaging the result. Each time we sample, we use a different position on the Vogel disk. This shadertoy demonstrates the look of this pattern.</p>
<!-- <iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/4l3yRM?gui=true&t=10&paused=false&muted=false" allowfullscreen></iframe> -->
<p>For the god ray shader, I use it to make the light beams appear softer, which I find very visually pleasing.</p>
<h1 id="paths-for-optimization">Paths For Optimization</h1>
<p>Upon reviewing the code, I finally had the time to address a concern I had with the original code:</p>
<p>Should I pre-compute all the sample positions on the CPU or compute them on the fly?</p>
<p>After all, computing the Vogel disk uses  <code>sin()</code>, <code>cos()</code> and <code>sqrt()</code>. These functions are notorious for being slow, or, to be more specific, running over multiple clock cycles.</p>
<p>Below are two variants I&rsquo;ve tested:</p>
<h2 id="1-on-the-fly">#1 On-The-Fly</h2>
<p>The Vogel disk and zoom blur positions are calculated on-the-fly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">vec2</span> VogelDiskSample(<span style="color:#ff79c6">int</span> sampleIndex, <span style="color:#ff79c6">int</span> sampleCount, <span style="color:#ff79c6">float</span> phi)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> sampleIndexf <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">float</span>(sampleIndex);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> sampleCountf <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">float</span>(sampleCount);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> goldenAngle <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2.39996</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> r <span style="color:#ff79c6">=</span> sqrt((sampleIndexf <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0.5</span>) <span style="color:#ff79c6">/</span> sampleCountf);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> theta <span style="color:#ff79c6">=</span> sampleIndexf <span style="color:#ff79c6">*</span> goldenAngle <span style="color:#ff79c6">+</span> phi;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">vec2</span>(cos(theta), sin(theta)) <span style="color:#ff79c6">*</span> r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">vec4</span> fragment_shader() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span>(<span style="color:#ff79c6">int</span> softnessSmpIdx <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; softnessSmpIdx <span style="color:#ff79c6">&lt;</span> softnessSmpCount; softnessSmpIdx<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// Compute the sample on-the-fly</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">vec2</span> sample <span style="color:#ff79c6">=</span> VogelDiskSample(softnessSmpIdx, softnessSmpCount, <span style="color:#bd93f9">0.0</span>) <span style="color:#ff79c6">*</span> blurRadius;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span>(<span style="color:#ff79c6">int</span> radialIdx <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; radialIdx <span style="color:#ff79c6">&lt;</span> radialSmpCount; radialIdx<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Compute the radial blur on-the-fly</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">float</span> stepSize <span style="color:#ff79c6">=</span> radialIdx <span style="color:#ff79c6">*</span> rangePerSample;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">vec2</span> uv <span style="color:#ff79c6">=</span> uvCentered <span style="color:#ff79c6">*</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">+</span> stepSize) <span style="color:#ff79c6">+</span> uvOffset ;
</span></span><span style="display:flex;"><span>            buffer <span style="color:#ff79c6">+=</span> texture(iChannel0, uv); 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2-pre-computed">#2 Pre-Computed</h2>
<p>The Vogel disk and the zoom blur positions are pre-calculated on the CPU.</p>
<blockquote>
<p>Using pre-computed data is also called a Look-Up-Table or LUT.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">vec4</span> fragment_shader() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> (<span style="color:#ff79c6">int</span> smpIndex <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; smpIndex <span style="color:#ff79c6">&lt;</span> sampleCount; smpIndex<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// Both Vogel and radial are pre-computed.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">vec4</span> sampleTS <span style="color:#ff79c6">=</span> sampleLut[smpIndex];
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">vec2</span> uvCentered <span style="color:#ff79c6">=</span> screenUv <span style="color:#ff79c6">-</span> sampleTS.zw;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">vec2</span> uv <span style="color:#ff79c6">=</span> uvCentered <span style="color:#ff79c6">*</span> sampleTS.xy <span style="color:#ff79c6">+</span> sampleTS.zw;
</span></span><span style="display:flex;"><span>        buffer <span style="color:#ff79c6">+=</span>  texture(iChannel0, uv);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Just from looking at the size of the code, the pre-computed version should run faster, because more code = more work, right?</p>
<p>Even when looking at the amount of assembler instructions (in DXBC), the same picture forms:</p>
<ul>
<li>On-The-Fly: 46 instructions</li>
<li>Pre-Computed: 26 instructions (-56%)</li>
</ul>
<p>But after all, we can&rsquo;t be certain, so let&rsquo;s run some benchmarks.</p>
<table>
<thead>
<tr>
<th></th>
<th>GTX 1050 Ti - 1/3</th>
<th>RTX 4070 - 1/3 Resolution</th>
<th>RTX 4070 - Full Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td>On-The-Fly</td>
<td>10.0ms</td>
<td>0.87ms</td>
<td>3.16ms</td>
</tr>
<tr>
<td>Pre-Computed</td>
<td>10.3ms (+3%)</td>
<td>0.95ms (+9%)</td>
<td>3.78ms (+16%)</td>
</tr>
</tbody>
</table>
<p>Huh, what is going on here? Why is the version with <em>more</em> instructions <em>faster</em>?</p>
<h1 id="the-impact-of-memory-latency">The Impact Of Memory Latency</h1>
<p>There is a second and often overlooked factor in performance, not only in the case of shaders, which is memory latency. This refers to the amount of time a processor has to wait to load a value from memory, mostly a significant time.</p>
<p>The on-the-fly method performs faster, because it is not so dependent on memory. It doesn&rsquo;t need to wait for the memory to know where to sample the texture we are trying to blur. It may have even already calculated that, <em>while</em> it was asking the memory to read the texture from a previous iteration of the loop.</p>
<blockquote>
<p>Modern GPUs are in fact able to suspend work on a pixel (or any other work item) while waiting for memory. This is called <em>latency hiding</em>. In our case, the computation of the Vogel disk may be effectively done in parallel, while a thread is waiting for the memory to read the texture. The effectiveness of latency hiding is dependent on the occupancy. For more info, checkout: <a href="https://gpuopen.com/learn/occupancy-explained/">https://gpuopen.com/learn/occupancy-explained/</a>.</p>
</blockquote>
<p>Simplified, the on-the-play method may run like this:</p>
<ol>
<li>Compute the value of <code>uv</code>.</li>
<li>Load/Sample from <code>iChannel0</code> with <code>uv</code>.</li>
<li><strong>Wait for memory.</strong></li>
<li>Write the resulting pixel to the frame buffer.</li>
</ol>
<hr>
<p>For the Pre-Computed method, the picture is different. Since the texture read itself is dependent on some data that is in memory, a thread needs to wait for that data <strong>first</strong>, before asking the memory <strong>a second time</strong> for the texture. At worst, no GPU thread is able to do anything, since all of them are waiting for memory.</p>
<p>Step-by-step it would roughly look like this:</p>
<ol>
<li>Ask the memory for <code>preComputedSamplesFromCPU[smpIndex]</code></li>
<li><strong>Wait for memory.</strong></li>
<li>Compute <code>uv</code> from the value of <code>sampleTS</code>.</li>
<li>Load/Sample from iChannel0 from <code>uv</code>.</li>
<li><strong>Wait for memory.</strong></li>
<li>Write the resulting pixel to the frame buffer.</li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Shader optimization may not always be achieved by reducing the amount of bare metal instructions. As demonstrated, having more instructions for the sake of less memory access may actually increase performance. Care must also be taken when memory reads are dependent on each other, as it is the case with pre-computed version mentioned.</p>
<h1 id="takeaways">Takeaways</h1>
<ul>
<li>Don&rsquo;t let instruction counts fool you. A lower instructions count doesn&rsquo;t always mean faster execution.</li>
<li>It is possible for code with more instructions to outperform code with fewer instructions, given enough memory usage.</li>
<li>Using LUTs can improve speed, but it can also backfire if the memory look-up is slower than doing the actual calculation.</li>
<li>Avoid memory accesses that is dependent on each other.</li>
<li>Always profile. Your intuition may not be correct.üôÇ</li>
</ul>
<hr>
<h3 id="bonus---hybrid-approach">Bonus - Hybrid approach</h3>
<p>For the sake of completion, I also tried a hybrid version. Here, only the vogel disk samples are pre-computed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#6272a4">// ...</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> (<span style="color:#ff79c6">int</span> smpIndex <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; smpIndex <span style="color:#ff79c6">&lt;</span> sampleCount; smpIndex<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// just pre-compute the vogel disk</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">vec2</span> sample <span style="color:#ff79c6">=</span> vogelDiskSamples[smpIndex] <span style="color:#ff79c6">*</span> blurRadius;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span>(<span style="color:#ff79c6">int</span> radialIdx <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; radialIdx <span style="color:#ff79c6">&lt;</span> radialSmpCount; radialIdx<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">float</span> stepSize <span style="color:#ff79c6">=</span> radialIdx <span style="color:#ff79c6">*</span> rangePerSample;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">vec2</span> uv <span style="color:#ff79c6">=</span> uvCentered <span style="color:#ff79c6">*</span> (<span style="color:#bd93f9">1.0</span> <span style="color:#ff79c6">+</span> stepSize) <span style="color:#ff79c6">+</span> uvOffset ;
</span></span><span style="display:flex;"><span>        buffer <span style="color:#ff79c6">+=</span> texture(iChannel0, uv); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//...</span>
</span></span></code></pre></div><p>It has an instruction count of 36. This version actually did perform better than the On-The-Fly method, but just by around ~2%.</p>
<hr>
<h1 id="further-reading">Further Reading</h1>
<ul>
<li><a href="https://gpuopen.com/learn/occupancy-explained/">GPU Open / Fran√ßois Guthmann - Occupancy explained</a></li>
</ul>

      </article>
      

      

    </div>
  </div>
</div>
<hr>
<script src="https://utteranc.es/client.js"
        repo="julhe/julhe.github.io"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

  </main>
  <footer class="footer">
  <div class="ax-l-i max-w-6xl">
    <nav class="flex items-center justify-center">
    </nav>
    <div class="footer-social flex items-center justify-center mt-4">
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Twitter" href="https://twitter.com/schneckerstein"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Github" href="https://github.com/julhe"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998 0C7.164 0 0 7.35 0 16.417 0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113 0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344 0 0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98 0 0 1 4.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406 0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836 0 15.998 0z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="LinkedIn" href="https://www.linkedin.com/in/julian-heinken-34463327/"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M29.692 0H2.308A2.31 2.31 0 0 0 0 2.308v27.384A2.31 2.31 0 0 0 2.308 32h27.384A2.31 2.31 0 0 0 32 29.692V2.308A2.31 2.31 0 0 0 29.692 0zM11.35 24.188H7.454V12.464h3.897v11.723zM9.402 10.863h-.025c-1.308 0-2.153-.9-2.153-2.025 0-1.15.872-2.026 2.205-2.026s2.153.875 2.18 2.026c0 1.125-.846 2.025-2.205 2.025zm16 13.324h-3.896v-6.272c0-1.576-.564-2.65-1.974-2.65-1.076 0-1.717.725-2 1.425-.103.25-.128.6-.128.95v6.547h-3.896V12.464h3.896v1.66c.518-.8 1.444-1.935 3.512-1.935 2.564 0 4.486 1.676 4.486 5.276v6.722z"/></svg></a>
    </div>

    <div class="footer-copyright text-sm text-center text-gray-500 mt-4">
      &#169; -2024 Julian Heinken
    </div>
    <div class="text-sm sm:text-xs text-center text-gray-500 mt-2">
      Powered by <a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral">Axiom</a>
    </div>
  </div>
</footer>

<script src="https://julhe.github.io/bundle.js?v=1708376611"></script>


</body>
</html>
