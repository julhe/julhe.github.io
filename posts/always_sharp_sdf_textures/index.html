<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name="hugo-theme" content="Axiom 0.7.2">



  <link rel="icon" type="image/png" sizes="32x32" href="https://julhe.github.io/">
  <link rel="icon" type="image/x-icon" href="https://julhe.github.io/">
  <link rel="apple-touch-icon" href="https://julhe.github.io/">
  <link rel="canonical" href="https://julhe.github.io/posts/always_sharp_sdf_textures/">
<link rel="preload" as="style" href="https://julhe.github.io/bundle.css?v=1711549386" media="all">
<link rel="stylesheet" href="https://julhe.github.io/bundle.css?v=1711549386" media="all">
<style>
  /* <code>:wrap */

.cdata pre {

    --tw-bg-opacity: 1;

    background-color: rgb(31 41 55 / var(--tw-bg-opacity))
}

.cdata pre {

    --tw-text-opacity: 1;

    color: rgb(229 231 235 / var(--tw-text-opacity))
}

/* <code>:inline */

.cdata :not(pre) > code {

    --tw-bg-opacity: 1;

    background-color: rgb(243 244 246 / var(--tw-bg-opacity))
}

.cdata :not(pre) > code {

    --tw-text-opacity: 1;

    color: rgb(147 51 234 / var(--tw-text-opacity))
}

/* Background */

.chroma {}

/* Other */

.chroma .x {}

/* Error */

.chroma .err {

    --tw-bg-opacity: 1;

    background-color: rgb(153 27 27 / var(--tw-bg-opacity));

    --tw-text-opacity: 1;

    color: rgb(254 202 202 / var(--tw-text-opacity))
}

/* LineTableTD */

.chroma .lntd {}

/* LineTable */

.chroma .lntable {}

/* LineHighlight */

.chroma .hl {

    --tw-bg-opacity: 1;

    background-color: rgb(55 65 81 / var(--tw-bg-opacity))
}

/* LineNumbersTable */

.chroma .lnt {}

/* LineNumbersTable */

.chroma .lnt {}

/* LineNumbers */

.chroma .ln {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* Keyword */

.chroma .k {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordConstant */

.chroma .kc {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordDeclaration */

.chroma .kd {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordNamespace */

.chroma .kn {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordPseudo */

.chroma .kp {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordReserved */

.chroma .kr {

    --tw-text-opacity: 1;

    color: rgb(96 165 250 / var(--tw-text-opacity))
}

/* KeywordType */

.chroma .kt {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* Name */

.chroma .n {}

/* NameAttribute */

.chroma .na {

    --tw-text-opacity: 1;

    color: rgb(250 204 21 / var(--tw-text-opacity))
}

/* NameBuiltin */

.chroma .nb {

    --tw-text-opacity: 1;

    color: rgb(251 146 60 / var(--tw-text-opacity))
}

/* NameBuiltinPseudo */

.chroma .bp {}

/* NameClass */

.chroma .nc {

    --tw-text-opacity: 1;

    color: rgb(248 113 113 / var(--tw-text-opacity))
}

/* NameConstant */

.chroma .no {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* NameDecorator */

.chroma .nd {

    --tw-text-opacity: 1;

    color: rgb(248 113 113 / var(--tw-text-opacity))
}

/* NameEntity */

.chroma .ni {}

/* NameException */

.chroma .ne {

    --tw-text-opacity: 1;

    color: rgb(248 113 113 / var(--tw-text-opacity))
}

/* NameFunction */

.chroma .nf {

    --tw-text-opacity: 1;

    color: rgb(251 146 60 / var(--tw-text-opacity))
}

/* NameFunctionMagic */

.chroma .fm {}

/* NameLabel */

.chroma .nl {}

/* NameNamespace */

.chroma .nn {}

/* NameOther */

.chroma .nx {}

/* NameProperty */

.chroma .py {}

/* NameTag */

.chroma .nt {

    --tw-text-opacity: 1;

    color: rgb(248 113 113 / var(--tw-text-opacity))
}

/* NameVariable */

.chroma .nv {}

/* NameVariableClass */

.chroma .vc {}

/* NameVariableGlobal */

.chroma .vg {}

/* NameVariableInstance */

.chroma .vi {}

/* NameVariableMagic */

.chroma .vm {}

/* Literal */

.chroma .l {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralDate */

.chroma .ld {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralString */

.chroma .s {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringAffix */

.chroma .sa {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringBacktick */

.chroma .sb {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringChar */

.chroma .sc {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringDelimiter */

.chroma .dl {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringDoc */

.chroma .sd {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringDouble */

.chroma .s2 {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringEscape */

.chroma .se {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* LiteralStringHeredoc */

.chroma .sh {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringInterpol */

.chroma .si {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringOther */

.chroma .sx {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringRegex */

.chroma .sr {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringSingle */

.chroma .s1 {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralStringSymbol */

.chroma .ss {

    --tw-text-opacity: 1;

    color: rgb(74 222 128 / var(--tw-text-opacity))
}

/* LiteralNumber */

.chroma .m {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberBin */

.chroma .mb {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberFloat */

.chroma .mf {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberHex */

.chroma .mh {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberInteger */

.chroma .mi {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberIntegerLong */

.chroma .il {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* LiteralNumberOct */

.chroma .mo {

    --tw-text-opacity: 1;

    color: rgb(192 132 252 / var(--tw-text-opacity))
}

/* Operator */

.chroma .o {

    --tw-text-opacity: 1;

    color: rgb(147 197 253 / var(--tw-text-opacity))
}

/* OperatorWord */

.chroma .ow {

    --tw-text-opacity: 1;

    color: rgb(147 197 253 / var(--tw-text-opacity))
}

/* Punctuation */

.chroma .p {

    --tw-text-opacity: 1;

    color: rgb(156 163 175 / var(--tw-text-opacity))
}

/* Comment */

.chroma .c {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentHashbang */

.chroma .ch {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentMultiline */

.chroma .cm {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentSingle */

.chroma .c1 {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentSpecial */

.chroma .cs {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentPreproc */

.chroma .cp {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* CommentPreprocFile */

.chroma .cpf {

    --tw-text-opacity: 1;

    color: rgb(107 114 128 / var(--tw-text-opacity))
}

/* Generic */

.chroma .g {}

/* GenericDeleted */

.chroma .gd {}

/* GenericEmph */

.chroma .ge {

    font-style: italic
}

/* GenericError */

.chroma .gr {}

/* GenericHeading */

.chroma .gh {}

/* GenericInserted */

.chroma .gi {}

/* GenericOutput */

.chroma .go {}

/* GenericPrompt */

.chroma .gp {}

/* GenericStrong */

.chroma .gs {

    font-weight: 700
}

/* GenericSubheading */

.chroma .gu {}

/* GenericTraceback */

.chroma .gt {}

/* GenericUnderline */

.chroma .gl {}

/* TextWhitespace */

.chroma .w {}
</style>

<link rel="preload" as="image" href="https://julhe.github.io/posts/always_sharp_sdf_textures/header.png">

<title>Always-Sharp SDF Textures : julhe.github.io</title>

<meta property="og:title" content="Always-Sharp SDF Textures">
<meta property="og:site_name" content="julhe.github.io">
<meta property="og:url" content="https://julhe.github.io/posts/always_sharp_sdf_textures/">
<link rel="image_src" href="https://julhe.github.io/posts/always_sharp_sdf_textures/header.png">
<meta property="og:image" content="https://julhe.github.io/posts/always_sharp_sdf_textures/header.png">
<meta property="og:image:width" content="">
<meta property="og:image:height" content="">
<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:description" content="A dive into texture filtering.">
<meta name="description" content="A dive into texture filtering.">
<meta property="og:updated_time" content="2024-03-01T10:07:14Z">
<meta property="fb:app_id" content="">
<meta name="author" content="Unknown">
<meta property="article:author" content="https://julhe.github.io/">
<meta property="article:published_time" content="2024-03-01T10:07:14Z">
<meta property="article:modified_time" content="2024-03-01T10:07:14Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Always-Sharp SDF Textures",
  "alternativeHeadline": "A dive into texture filtering.",
  "url": "https://julhe.github.io/posts/always_sharp_sdf_textures/",
  "image": "https://julhe.github.io/posts/always_sharp_sdf_textures/header.png",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://julhe.github.io/posts/always_sharp_sdf_textures/"
  },
  "description": "A dive into texture filtering.",
  "author": {
    "@type": "Person",
    "name": "Unknown"
  },
  "publisher": {
    "@type": "Organization",
    "name": "julhe.github.io",
    "logo": {
      "@type": "ImageObject",
      "url": "https://julhe.github.io/"
    }
  },
  "datePublished": "2024-03-01T10:07:14Z",
  "dateModified": "2024-03-01T10:07:14Z",
  "articleBody": "\u003ch1 id=\"tldr\"\u003eTL;DR\u003c/h1\u003e\n\u003cp\u003e\u003cem\u003eRender infinitely sharp and anti-aliased SDF by using adaptive sharpening. The sharpening value is calculated from the area that is formed by the Jacobian Matrix of the UV coordinate.\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"web-demo\"\u003eWeb Demo\u003c/h3\u003e\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js\" integrity=\"sha256-HJ7j+71YYw6Kcs8THwQV9lXmPOcR0eXlg7n8KRTZsyA=\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e\r\n\u003cscript src=\"sdfExample.js\" type=\"module\"\u003e\u003c/script\u003e\r\n\u003cdiv id=\"theeJsExampleWrapper\" style=\"position: relative; width: 784px; height 420px;\"\u003e\r\n\u003ccanvas id=\"threeJsCanvas\"\u003e \u003c/canvas\u003e\r\n\u003cdiv id=\"datGuiContainer\"\u003e \u003c/div\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e\u003cem\u003e🖱 LMB: Rotate Camera, MW: Zoom, RMB: Pan Camera\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eTeapot model downloaded from Morgan McGuire\u0026rsquo;s \u003ca href=\"https://casual-effects.com/data\"\u003eComputer Graphics Archive\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003ch1 id=\"intro\"\u003eIntro\u003c/h1\u003e\n\u003ch2 id=\"signed-distance-field-recap\"\u003eSigned Distance Field Recap\u003c/h2\u003e\n\u003cp\u003eA \u003ca href=\"https://shaderfun.com/2018/03/23/signed-distance-fields-part-1-unsigned-distance-fields/\"\u003eSigned Distance Field (SDF)\u003c/a\u003e describes a shape by the distance to its closest feature at a given point. A simple example, a wo-dimensional circle, can be described mathematically as:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e circleSdf2d(\u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e samplePosition, \u003cspan style=\"color:#ff79c6\"\u003evec2\u003c/span\u003e circlePosition, \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e circleRadius){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e length(samplePosition \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e circlePosition) \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e circleRadius; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eTo actually draw the circle with this function, we would run it for each pixel (using the sample position as the pixel coordinate). If the distance is smaller than 0, we are \u003cem\u003einside\u003c/em\u003e the circle.\u003c/p\u003e\n\u003cp\u003eWe are not limited to circles. More advanced shapes, such as a star, are also possible. This is demonstrated below. Note that the area with a negative distance is colored red.\u003c/p\u003e\n\u003ciframe width=\"640\" height=\"360\" frameborder=\"0\" src=\"https://www.shadertoy.com/embed/dsVBWK?gui=false\u0026t=10\u0026paused=false\u0026muted=false\" allowfullscreen\u003e\u003c/iframe\u003e\r\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCompared to a rasterized image, an SDF can always be sharp, no matter how much you zoom in.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFrom here on, the possibilities of SDFs are enormous and not limited to 2D. Many demos you find on \u003ca href=\"https://www.shadertoy.com/\"\u003ehttps://www.shadertoy.com/\u003c/a\u003e are built on top of this idea. A comprehensive list can be found here: \u003ca href=\"http://iquilezles.org/articles/distfunctions2d/\"\u003ehttp://iquilezles.org/articles/distfunctions2d/\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn this article, I will only look into rendering SDFs as simple masks. You can also use gradients, simply by multiplying the final sharpening value we are caluclating here.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"signed-distance-fields-and-textures\"\u003eSigned Distance Fields And Textures\u003c/h2\u003e\n\u003cp\u003eFor many real-time applications, using a zoo of mathematical functions every frame may be too expensive or otherwise unpractical. For example, rendering text with SDFs is a very nice thing to have, given its always-sharp quality. But the glyphs of a font may consist of many individual curves, making it too expensive to calculate every frame. Or take a hand-drawn mask, for example: it can\u0026rsquo;t even be properly expressed as an SDF.\u003c/p\u003e\n\u003cp\u003eThe solution here is to store the SDF in a texture. \u003ca href=\"https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\"\u003eThis was used by Valve since back in 2007\u003c/a\u003e. The most primitive shader snippet that renders such an SDF from a texture may look like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e SampleSDFMask(texture2D _SDFTexture, float2 uv) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e sdf_raw \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e tex2D(_SDFTexture, i.uv);\t\t\u003cspan style=\"color:#6272a4\"\u003e// sample\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e mask \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e saturate(sdf_raw \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e2.0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1.0\u003c/span\u003e);\t\u003cspan style=\"color:#6272a4\"\u003e// unpack from [0, 1] to [-1, 1] and clamp. (Assuming an area of 1.0 / size-per-texel)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e mask; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSo in practice, we just increase the contrast of the texture and call it done. For different scaling factors, you may simply use different unpacking or sharpening factors. And that\u0026rsquo;s just fine if you render something where each texel ends up at exactly one pixel on the screen. Or, in other words, the area that a single rendered pixel covers is constant.\u003c/p\u003e\n\u003ch2 id=\"sdf-textures-in-3d\"\u003eSDF Textures in 3D\u003c/h2\u003e\n\u003cp\u003eIf you want to use an SDF as a texture in 3D, things get tricky, as SDFs can become too crisp in the distance or not sharp enough close up.\u003c/p\u003e\n\r\n\r\n\u003cfigure\u003e\r\n\u003cimg\r\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\r\nsrc=\"/posts/always_sharp_sdf_textures/aliasingSDF.png\"\r\nalt=\"A signed distance field texture that aliases. Notice how the pattern dissolves in the distance.\"\u003e\r\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n\u003cp\u003eA signed distance field texture that aliases. Notice how the pattern dissolves in the distance.\u003c/p\u003e\r\n\u003c/figcaption\u003e\r\n\u003c/figure\u003e\r\n\n\u003cp\u003eThis is because the distance between two pixels on our SDF-Texture is always constant when viewed in 2D. It is not the same once that texture gets mapped on any 3D surface, due to the perspective transformation. Therefore, we need to know the distance between two texels after the perspective transformation has taken place.\u003c/p\u003e\n\u003cp\u003eBut how do we calculate that distance?\u003c/p\u003e\n\r\n\r\n\u003cfigure\u003e\r\n\u003cimg\r\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\r\nsrc=\"/posts/always_sharp_sdf_textures/aliasingSDF_withFilter.png\"\r\nalt=\"A signed distance field texture that doesn\u0026amp;rsquo;t alias, using the technique we will develop. Notice how the pattern remains visible in the distance.\"\u003e\r\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n\u003cp\u003eA signed distance field texture that doesn\u0026rsquo;t alias, using the technique we will develop. Notice how the pattern remains visible in the distance.\u003c/p\u003e\r\n\u003c/figcaption\u003e\r\n\u003c/figure\u003e\r\n\n\u003ch2 id=\"mipmapping\"\u003eMipmapping\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s step back a bit from our problem and look at a problem that is similar to ours, but already well fixed: texture aliasing.\u003c/p\u003e\n\r\n\r\n\u003cfigure\u003e\r\n\u003cimg\r\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\r\nsrc=\"/posts/always_sharp_sdf_textures/aliasingTexture.png\"\r\nalt=\"A grid texture without Mipmaps. Notice how the lines of the grid get incomplete at a distance.\"\u003e\r\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n\u003cp\u003eA grid texture without Mipmaps. Notice how the lines of the grid get incomplete at a distance.\u003c/p\u003e\r\n\u003c/figcaption\u003e\r\n\u003c/figure\u003e\r\n\n\r\n\r\n\u003cfigure\u003e\r\n\u003cimg\r\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\r\nsrc=\"/posts/always_sharp_sdf_textures/aliasingTexture_WithMipmaps.png\"\r\nalt=\"A grid texture with mipmaps. Notice how the lines of the grid remain intact.\"\u003e\r\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n\u003cp\u003eA grid texture with mipmaps. Notice how the lines of the grid remain intact.\u003c/p\u003e\r\n\u003c/figcaption\u003e\r\n\u003c/figure\u003e\r\n\n\u003cp\u003eWhen simply mapping a texture onto a 3D surface, chances are high that we will introduce \u003cem\u003ealiasing\u003c/em\u003e. That means we are skipping over information, because we are sampling (with the camera) at a lower frequency than the information is available (the texture). This leads to a somewhat noisy and unusable image. Even small movements with the camera will introduce unpleasant noise.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOf course unpleasant is subjective, many retro-esque 3D games use aliasing as part of their visual identity.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe solution to the problem is to have multiple downsized versions of the texture in question. Each mipmap is half the size of the previous mipmap, so that each texel can be seen as a \u0026ldquo;summary\u0026rdquo; of four pixels from the larger version.\u003c/p\u003e\n\r\n\r\n\u003cfigure\u003e\r\n\u003cimg\r\nclass=\"mb-2 mx-auto leading-none shadow-xl\"\r\nsrc=\"https://upload.wikimedia.org/wikipedia/commons/5/5c/MipMap_Example_STS101.jpg\"\r\nalt=\"An image and the corresponding mipmaps on the right side. From Wikipedia\"\u003e\r\n\u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n\u003cp\u003eAn image and the corresponding mipmaps on the right side. \u003ca href=\"https://en.wikipedia.org/wiki/Mipmap#/media/File:MipMap_Example_STS101.jpg\"\u003eFrom Wikipedia\u003c/a\u003e\u003c/p\u003e\r\n\u003c/figcaption\u003e\r\n\u003c/figure\u003e\r\n\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThere is a hidden art on how the process of downsampling is done, mainly involving the use of different \u003cem\u003efilter kernels\u003c/em\u003e, such as Box, Gaussian or Mitchell. Each of them will give different results, but usually Box is not preferred.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNow, we sample a texture through a shader, say by \u003ccode\u003etex2D(_Texture, uvCoordinate)\u003c/code\u003e, \u003cem\u003ethrough some magic\u003c/em\u003e, the GPU knows exactly what mipmap to use, so that it never skips over texels or displays a too blurry version. We can kinda guess that it has something to do with the viewing angle and viewing distance, but the solution is much more fun. 😉\u003c/p\u003e\n\u003ch2 id=\"the-screen-space-derivative\"\u003eThe Screen Space Derivative\u003c/h2\u003e\n\u003cp\u003eThe main part of that magic is actually the \u003cstrong\u003escreen space derivative\u003c/strong\u003e, a handy and special feature of any modern GPU. Instead of trying to guess the area from any viewing angle or distance, we simply use the screen space derivative to get the \u003cem\u003erate of change\u003c/em\u003e of the UV coordinate, with respect to the screen.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn fact, the GPU itself doesn\u0026rsquo;t even have much of a concept of what viewing angle or viewing distance is. The information to calculate this may not even be supplied in the first place. (Think of what should happen to a mesh without normals to calculate a viewing angle.) \u003cstrong\u003eBy the way\u003c/strong\u003e if you have access to this information, check out the \u003cem\u003eDynamic Dilation\u003c/em\u003e section in the white paper of the \u003ca href=\"https://sluglibrary.com/slug_algorithm.pdf\"\u003eSlug Font Rendering library\u003c/a\u003e. You could use the given formula to calculate the derivatives on a per-vertex level.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is also the reason why even a triangle that is just 1x1 pixels large still generates workload for 2x2 pixels. Even for that single pixel, the GPU needs to know the derivatives. This is a problem with highly detailed meshes and commonly known as \u003cem\u003equad overdraw\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWhile for \u003ccode\u003etex2D()\u003c/code\u003e this happens under the hood, since Shader Model 3.0 (in DirectX lingo), you are able to get the derivatives for any variable you want, via the HLSL functions \u003ca href=\"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-ddx\"\u003eddx()\u003c/a\u003e and \u003ca href=\"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-ddy\"\u003eddy()\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003eddx(MyUvCoordinate)\u003c/code\u003e will give you the rate of change of \u003ccode\u003eMyUvCoordinate\u003c/code\u003e on the X-axis of the screen and \u003ccode\u003eddy(MyUvCoordinate)\u003c/code\u003e for the Y-axis. Getting the screen space derivative for any constant value, let\u0026rsquo;s say \u003ccode\u003eddx(42)\u003c/code\u003e, will always give you always 0, as 42 is constant and never changes over the course of the screen.\u003c/p\u003e\n\u003cp\u003eThe following video may give you an idea of how this looks:\u003c/p\u003e\n \u003cvideo controls=\"controls\" loop=\"true\" autoplay\u003e\r\n  \u003csource type=\"video/mp4\" src=\"uv_derivate_anim.mp4\"\u003e\u003c/source\u003e\r\n  \u003cp\u003eYour browser does not support the video element.\u003c/p\u003e\r\n\u003c/video\u003e\r\nNote that I'm showing the length/magnitude (\"| |\") of the derivative in the video for better illustration.\r\n\u003cblockquote\u003e\n\u003cp\u003eThe fragment shader for the left and middle quad.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efloat4 \u003cspan style=\"color:#50fa7b\"\u003efrag\u003c/span\u003e(VertexInput input) \u003cspan style=\"color:#ff79c6\"\u003e:\u003c/span\u003e SV_Target0{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003elength\u003c/span\u003e(\u003cspan style=\"color:#50fa7b\"\u003eddx\u003c/span\u003e(input.uv)); \u003cspan style=\"color:#6272a4\"\u003e// ddy for middle\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"the-pixel-footprint\"\u003eThe Pixel Footprint\u003c/h2\u003e\n\u003cp\u003eThe screen space derivatives alone don\u0026rsquo;t tell us much, so let\u0026rsquo;s focus on how we get something useful out of them. For better understanding, let\u0026rsquo;s introduce the concept of the \u003cem\u003epixel footprint\u003c/em\u003e.\nThis refers to the area that an individual pixel \u003cem\u003esees\u003c/em\u003e.\u003c/p\u003e\n\r\n \r\n \u003cfigure\u003e\r\n \u003cimg\r\n class=\"mb-2 mx-auto leading-none shadow-xl\"\r\n src=\"/posts/always_sharp_sdf_textures/ddxddy.png\"\r\n alt=\"ddX and ddY, displayed as vectors projected onto a triangle. Anisotropic diameter in yellow. The white square represents a single pixel.\"\u003e\r\n \u003cfigcaption class=\"text-sm text-right text-raven-500\"\u003e\r\n \u003cp\u003eddX and ddY, displayed as vectors projected onto a triangle. Anisotropic diameter in yellow. The white square represents a single pixel.\u003c/p\u003e\r\n \u003c/figcaption\u003e\r\n \u003c/figure\u003e\r\n\n\u003cp\u003eWe can treat the X and Y screen space derivatives (ddx and ddy) as vectors that span a parallelogram.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhile the pixel footprint is not a parallelogram, it is an approximation that works very well most of the time.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe can use this fact to calculate the area, diameter and longest side of the pixel footprint. For mipmaps, it is going to be the longest side, for our SDF the diameter, more on that later.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI don\u0026rsquo;t know \u003cem\u003ewhy\u003c/em\u003e the longest side is used for mip mapping for sure, but I assume that, since it is the most conservative value, even with heavily distorted UVs it wouldn\u0026rsquo;t introduce aliasing.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEquipped with this knowledge, we can now calculate the mipmap index ourselves.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e GetMipMapLevel(float2 uv, float2 texel_size) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// convert UV space [0,1] to texel space [0..axis_size].\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    float2 dx_uv \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ddx(uv) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e texel_size; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    float2 dy_uv \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e ddy(uv) \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e texel_size;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// calculate the squared length of the longest axis.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003efloat\u003c/span\u003e longest_side \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e max(dot(dx_uv, dx_uv), dot(dy_uv, dy_uv)); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// take the square root of the squared-longest-side and use log2 to get the according mip-map index. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Log2 is used because mip-maps are index by thier base to the power-of-two.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Note that: 0.5 * log2(longest_side) == log2(sqrt(longest_side)) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e0.5\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e log2(longest_side); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eYou can also look at the reference here: \u003ca href=\"https://registry.khronos.org/OpenGL/specs/gl/glspec42.core.pdf\"\u003ethe OpenGL 4.2 specifications\u003c/a\u003e. Look at equation 3.21. Note that, for some reasons, the formula doesn\u0026rsquo;t take the texture resolution into account. It will not work out of the box when you use it in shader code. This is \u0026ldquo;fixed\u0026rdquo; in the above version. If you know more about why it is like this in the specs, I\u0026rsquo;d be happy to hear!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"filtering-the-sdf\"\u003eFiltering The SDF\u003c/h2\u003e\n\u003cp\u003eFor the SDF, however, we are not interested in the mip-map level.\u003c/p\u003e\n\u003cp\u003eRemember, our initial goal was to calculate the distance between two texels after the perspective transformation. Instead of the longest side as for mip-maps we are going to use the diameter of the pixel footprints area this.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn my tests using the diameter had better sharpening and less aliasing, especially on step viewing angles.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTo calculate the area first, we can use the \u003cem\u003eJacobian Matrix\u003c/em\u003e, a matrix that is built by the partial derivatives, in our case, the screen space derivatives of the UV. In HLSL, it is built as \u003ccode\u003efloat2x2 uvJacobian = float2x2(ddx(uv), ddy(uv))\u003c/code\u003e. If we now calculate the \u003cem\u003edeterminant\u003c/em\u003e, we get a value that essentially indicates the \u0026ldquo;space distortion\u0026rdquo; of a matrix. In the case of the 2D Jacobian Matrix, this is identical to calculating \u003ca href=\"https://en.wikipedia.org/wiki/Parallelogram#Area_in_terms_of_Cartesian_coordinates_of_vertices\"\u003ethe area of a parallelogram\u003c/a\u003e. Finally, after the taking the square root of the area, we got what we needed.\u003c/p\u003e\n\u003cp\u003eThis animation may help visualize what is happening with the diameter under different viewing conditions.\u003c/p\u003e\n \u003cvideo controls=\"controls\" loop=\"true\" autoplay\u003e\r\n  \u003csource type=\"video/mp4\" src=\"uvfootprint.mp4\"\u003e\u003c/source\u003e\r\n  \u003cp\u003eYour browser does not support the video element.\u003c/p\u003e\r\n\u003c/video\u003e\r\n\u003cp\u003eIf we multiply the pixel footprint area by the number of texels (the texture resolution), we get the area in texel space that the pixel covers. That means that if this value is 1.0, we have exactly one texel under the pixel. A value larger than 1.0 means more than one texel per pixel, and vice versa.\u003c/p\u003e\n\u003cp\u003ePutting it together, we get:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#8be9fd\"\u003efloat\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eFilterSdfTextureExact\u003c/span\u003e(\u003cspan style=\"color:#8be9fd\"\u003efloat\u003c/span\u003e sdf, float2 uvCoordinate, float2 textureSize) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Calculate the derivative of the UV coordinate and build the jacobian-matrix from it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    float2x2 pixelFootprint \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003ehalf2x2\u003c/span\u003e(\u003cspan style=\"color:#50fa7b\"\u003eddx\u003c/span\u003e(uvCoordinate), \u003cspan style=\"color:#50fa7b\"\u003eddy\u003c/span\u003e(uvCoordinate));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Calculate the area under the pixel.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Note the use of abs(), because the area may be negative.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#8be9fd\"\u003efloat\u003c/span\u003e pixelFootprintDiameterSqr \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003eabs\u003c/span\u003e(\u003cspan style=\"color:#50fa7b\"\u003edeterminant\u003c/span\u003e(pixelFootprint)); \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Multiply by texture size.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    pixelFootprintDiameterSqr \u003cspan style=\"color:#ff79c6\"\u003e*=\u003c/span\u003e textureSize.x \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e textureSize.y ;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Compute the diameter.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#8be9fd\"\u003efloat\u003c/span\u003e pixelFootprintDiameter \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esqrt\u003c/span\u003e(pixelFootprintDiameterSqr);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#6272a4\"\u003e// Clamp the filter width to [0, 1] so we won\u0026#39;t overfilter, which fades the texture into grey\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#6272a4\"\u003e\u003c/span\u003e    pixelFootprintDiameter \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esaturate\u003c/span\u003e(pixelFootprintDiameter) ; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#50fa7b\"\u003esaturate\u003c/span\u003e(\u003cspan style=\"color:#50fa7b\"\u003einverseLerp\u003c/span\u003e(\u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003epixelFootprintDiameter, pixelFootprintDiameter, sdf));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"bonus-why-not-just-use-fwidth-directly-for-filtering\"\u003eBonus: Why Not Just Use fwidth() Directly For Filtering?\u003c/h3\u003e\n\u003cp\u003eSome resources may point out the usage of \u003ccode\u003efwidth()\u003c/code\u003e directly, as in\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-glsl\" data-lang=\"glsl\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e SampleSDFMask(texture2D _SDFTexture, float2 uv) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e sdf_raw \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e tex2D(_SDFTexture, i.uv);\t\t\u003cspan style=\"color:#6272a4\"\u003e// sample\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e mask_fwidth \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e fwidth(mask);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ehalf\u003c/span\u003e mask \u003cspan style=\"color:#ff79c6\"\u003e=\u003c/span\u003e saturate((sdf_raw \u003cspan style=\"color:#ff79c6\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e2.0\u003c/span\u003e \u003cspan style=\"color:#ff79c6\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#bd93f9\"\u003e1.0\u003c/span\u003e) \u003cspan style=\"color:#ff79c6\"\u003e/\u003c/span\u003e mask_fwidth);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#ff79c6\"\u003ereturn\u003c/span\u003e mask; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e} \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eAs a recap, fwidth() is defined as \u003ccode\u003eabs(ddx(p)) + abs(ddy(p))\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo instead of taking the derivative of the UV, we take the sampled SDF value directly.\u003c/p\u003e\n\u003cp\u003eThis is not optimal for two reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt will introduce aliasing, since the \u0026ldquo;sharpening value\u0026rdquo; is calculated for 2x2 pixel blocks and not per-pixel.\u003c/li\u003e\n\u003cli\u003eIt creates a hidden dependency between the pixels, because in order to know the value of \u003ccode\u003emask_fwidth\u003c/code\u003e, all four pixels need to know the value of \u003ccode\u003emask\u003c/code\u003e first.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"final-code\"\u003eFinal Code\u003c/h3\u003e\n\u003cscript src=\"https://gist.github.com/julhe/fa278c09ce577711c43296955ffc54a0.js\"\u003e\u003c/script\u003e\r\n\u003chr\u003e\n\u003ch1 id=\"further-reading\"\u003eFurther Reading\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/1111411.1111433\"\u003eReal-Time Texture-Mapped Vector Glyphs [Qin et al. 2006]\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"
}
</script>

<link rel="preload" as="script" href="https://julhe.github.io/bundle.js?v=1711549386">


</head>
<body>

  <header id="nav" class="header">
  <div class="ax-l-i max-w-6xl">
    <div class="ax-logo">
      <a class="block" href="https://julhe.github.io/" title="julhe.github.io"><span class="font-semibold text-raven-900">julhe.github.io</span></a>
    </div>
    <div class="ax-user">
      <a class="p-2 w-8 h-8 block text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" target="_blank" rel="noopener nofollow" href="https://www.google.com/search?q=site:https%3a%2f%2fjulhe.github.io%2f" title="Search">
        <svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M2.67 12.804c0-5.6 4.544-10.134 10.133-10.134s10.134 4.544 10.134 10.134-4.544 10.133-10.134 10.133S2.67 18.393 2.67 12.804zm28.943 16.923l-8.868-8.868c4.287-5.3 3.68-13.012-1.378-17.57S8.564-1.066 3.75 3.75s-5.017 12.558-.46 17.618 12.28 5.665 17.57 1.378l8.868 8.868a1.33 1.33 0 0 0 2.231-.597c.123-.46-.008-.952-.345-1.29h0z"/></svg>

      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://julhe.github.io/about">
        About
      </a>
      <a class="p-2 block text-base leading-none text-raven-500 hover:text-gray-800 focus:text-gray-800 focus:outline-none" href="https://julhe.github.io/posts">
        Posts
      </a>
    </div>
  </div>

  
</header>

  <main>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<div class="default-single">
  <div class="ax-title ax-l-o">
    <div class="ax-l-i max-w-680">
      <h1 class="post-title font-content-title font-normal leading-tight tracking-default text-40">Always-Sharp SDF Textures</h1>

      <div class="ax-meta flex items-center mt-5">
        <div class="flex-grow min-w-0">
          <div class="flex items-center">
  <div class="flex-shrink-0">
    
  </div>
  <div class="flex-shrink-0 ml-2 leading-tight font-content-sans">
    <a class="block text-sm text-raven-800 hover:text-raven-900 hover:underline focus:underline" target="_blank" rel="noopener nofollow" title="Unknown" href="https://julhe.github.io/">Unknown</a>
    <time class="text-sm text-raven-500" datetime="2024-03-01T10:07:14Z">Mar 1, 2024 11:07AM</time>
  </div>
</div>

        </div>
        <div>
          <div class="flex items-center">
  <a class="flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Twitter" href="https://twitter.com/intent/tweet?text=Always-Sharp%20SDF%20Textures%20by%20%40%23%20https%3a%2f%2fjulhe.github.io%2fposts%2falways_sharp_sdf_textures%2f"><svg class="w-6 h-6 fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg>
</a>
  <a class="ml-3 flex-shrink-0 block text-raven-800 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Share on Facebook" href="https://www.facebook.com/dialog/share?app_id=&display=page&href=https%3a%2f%2fjulhe.github.io%2fposts%2falways_sharp_sdf_textures%2f"><svg class="w-6 h-6 fill-current" viewBox="-7 -3.5 39 39" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M30.234 0H1.765C.8.001 0 .79 0 1.766v28.47C.001 31.2.79 32 1.766 32h15.328V19.625h-4.156V14.78h4.156v-3.564c0-4.134 2.523-6.384 6.21-6.384 1.766 0 3.284.13 3.726.2v4.32h-2.543c-2.006 0-2.394.953-2.394 2.352v3.085h4.797l-.625 4.844h-4.172V32h8.14C31.21 32 32 31.2 32 30.234V1.765C32 .8 31.21 0 30.234 0z"/></svg>
</a>
</div>

        </div>
      </div>
    </div>
  </div>
  <div class="ax-feature ax-l-o">
    <div class="ax-l-i max-w-5xl">

<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/always_sharp_sdf_textures/header.png"
alt="Always-Sharp SDF Textures">
</figure>

    </div>
  </div><div class="ax-content ax-l-o">
    <div class="ax-l-i max-w-680">
      <article class="cdata">
<h1 id="tldr">TL;DR</h1>
<p><em>Render infinitely sharp and anti-aliased SDF by using adaptive sharpening. The sharpening value is calculated from the area that is formed by the Jacobian Matrix of the UV coordinate.</em></p>
<h3 id="web-demo">Web Demo</h3>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js" integrity="sha256-HJ7j+71YYw6Kcs8THwQV9lXmPOcR0eXlg7n8KRTZsyA=" crossorigin="anonymous"></script>
<script src="sdfExample.js" type="module"></script>
<div id="theeJsExampleWrapper" style="position: relative; width: 784px; height 420px;">
<canvas id="threeJsCanvas"> </canvas>
<div id="datGuiContainer"> </div>
</div>
<p><em>🖱 LMB: Rotate Camera, MW: Zoom, RMB: Pan Camera</em></p>
<p><em>Teapot model downloaded from Morgan McGuire&rsquo;s <a href="https://casual-effects.com/data">Computer Graphics Archive</a></em></p>
<h1 id="intro">Intro</h1>
<h2 id="signed-distance-field-recap">Signed Distance Field Recap</h2>
<p>A <a href="https://shaderfun.com/2018/03/23/signed-distance-fields-part-1-unsigned-distance-fields/">Signed Distance Field (SDF)</a> describes a shape by the distance to its closest feature at a given point. A simple example, a wo-dimensional circle, can be described mathematically as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">float</span> circleSdf2d(<span style="color:#ff79c6">vec2</span> samplePosition, <span style="color:#ff79c6">vec2</span> circlePosition, <span style="color:#ff79c6">float</span> circleRadius){
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> length(samplePosition <span style="color:#ff79c6">-</span> circlePosition) <span style="color:#ff79c6">-</span> circleRadius; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To actually draw the circle with this function, we would run it for each pixel (using the sample position as the pixel coordinate). If the distance is smaller than 0, we are <em>inside</em> the circle.</p>
<p>We are not limited to circles. More advanced shapes, such as a star, are also possible. This is demonstrated below. Note that the area with a negative distance is colored red.</p>
<iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/dsVBWK?gui=false&t=10&paused=false&muted=false" allowfullscreen></iframe>
<blockquote>
<blockquote>
<p>Compared to a rasterized image, an SDF can always be sharp, no matter how much you zoom in.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>From here on, the possibilities of SDFs are enormous and not limited to 2D. Many demos you find on <a href="https://www.shadertoy.com/">https://www.shadertoy.com/</a> are built on top of this idea. A comprehensive list can be found here: <a href="http://iquilezles.org/articles/distfunctions2d/">http://iquilezles.org/articles/distfunctions2d/</a>.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>In this article, I will only look into rendering SDFs as simple masks. You can also use gradients, simply by multiplying the final sharpening value we are caluclating here.</p>
</blockquote>
</blockquote>
<h2 id="signed-distance-fields-and-textures">Signed Distance Fields And Textures</h2>
<p>For many real-time applications, using a zoo of mathematical functions every frame may be too expensive or otherwise unpractical. For example, rendering text with SDFs is a very nice thing to have, given its always-sharp quality. But the glyphs of a font may consist of many individual curves, making it too expensive to calculate every frame. Or take a hand-drawn mask, for example: it can&rsquo;t even be properly expressed as an SDF.</p>
<p>The solution here is to store the SDF in a texture. <a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">This was used by Valve since back in 2007</a>. The most primitive shader snippet that renders such an SDF from a texture may look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">half</span> SampleSDFMask(texture2D _SDFTexture, float2 uv) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">half</span> sdf_raw <span style="color:#ff79c6">=</span> tex2D(_SDFTexture, i.uv);		<span style="color:#6272a4">// sample</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">half</span> mask <span style="color:#ff79c6">=</span> saturate(sdf_raw <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2.0</span> <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1.0</span>);	<span style="color:#6272a4">// unpack from [0, 1] to [-1, 1] and clamp. (Assuming an area of 1.0 / size-per-texel)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> mask; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So in practice, we just increase the contrast of the texture and call it done. For different scaling factors, you may simply use different unpacking or sharpening factors. And that&rsquo;s just fine if you render something where each texel ends up at exactly one pixel on the screen. Or, in other words, the area that a single rendered pixel covers is constant.</p>
<h2 id="sdf-textures-in-3d">SDF Textures in 3D</h2>
<p>If you want to use an SDF as a texture in 3D, things get tricky, as SDFs can become too crisp in the distance or not sharp enough close up.</p>


<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/always_sharp_sdf_textures/aliasingSDF.png"
alt="A signed distance field texture that aliases. Notice how the pattern dissolves in the distance.">
<figcaption class="text-sm text-right text-raven-500">
<p>A signed distance field texture that aliases. Notice how the pattern dissolves in the distance.</p>
</figcaption>
</figure>

<p>This is because the distance between two pixels on our SDF-Texture is always constant when viewed in 2D. It is not the same once that texture gets mapped on any 3D surface, due to the perspective transformation. Therefore, we need to know the distance between two texels after the perspective transformation has taken place.</p>
<p>But how do we calculate that distance?</p>


<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/always_sharp_sdf_textures/aliasingSDF_withFilter.png"
alt="A signed distance field texture that doesn&amp;rsquo;t alias, using the technique we will develop. Notice how the pattern remains visible in the distance.">
<figcaption class="text-sm text-right text-raven-500">
<p>A signed distance field texture that doesn&rsquo;t alias, using the technique we will develop. Notice how the pattern remains visible in the distance.</p>
</figcaption>
</figure>

<h2 id="mipmapping">Mipmapping</h2>
<p>Let&rsquo;s step back a bit from our problem and look at a problem that is similar to ours, but already well fixed: texture aliasing.</p>


<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/always_sharp_sdf_textures/aliasingTexture.png"
alt="A grid texture without Mipmaps. Notice how the lines of the grid get incomplete at a distance.">
<figcaption class="text-sm text-right text-raven-500">
<p>A grid texture without Mipmaps. Notice how the lines of the grid get incomplete at a distance.</p>
</figcaption>
</figure>



<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://julhe.github.io/posts/always_sharp_sdf_textures/aliasingTexture_WithMipmaps.png"
alt="A grid texture with mipmaps. Notice how the lines of the grid remain intact.">
<figcaption class="text-sm text-right text-raven-500">
<p>A grid texture with mipmaps. Notice how the lines of the grid remain intact.</p>
</figcaption>
</figure>

<p>When simply mapping a texture onto a 3D surface, chances are high that we will introduce <em>aliasing</em>. That means we are skipping over information, because we are sampling (with the camera) at a lower frequency than the information is available (the texture). This leads to a somewhat noisy and unusable image. Even small movements with the camera will introduce unpleasant noise.</p>
<blockquote>
<blockquote>
<p>Of course unpleasant is subjective, many retro-esque 3D games use aliasing as part of their visual identity.</p>
</blockquote>
</blockquote>
<p>The solution to the problem is to have multiple downsized versions of the texture in question. Each mipmap is half the size of the previous mipmap, so that each texel can be seen as a &ldquo;summary&rdquo; of four pixels from the larger version.</p>


<figure>
<img
class="mb-2 mx-auto leading-none shadow-xl"
src="https://upload.wikimedia.org/wikipedia/commons/5/5c/MipMap_Example_STS101.jpg"
alt="An image and the corresponding mipmaps on the right side. From Wikipedia">
<figcaption class="text-sm text-right text-raven-500">
<p>An image and the corresponding mipmaps on the right side. <a href="https://en.wikipedia.org/wiki/Mipmap#/media/File:MipMap_Example_STS101.jpg">From Wikipedia</a></p>
</figcaption>
</figure>

<blockquote>
<blockquote>
<p>There is a hidden art on how the process of downsampling is done, mainly involving the use of different <em>filter kernels</em>, such as Box, Gaussian or Mitchell. Each of them will give different results, but usually Box is not preferred.</p>
</blockquote>
</blockquote>
<p>Now, we sample a texture through a shader, say by <code>tex2D(_Texture, uvCoordinate)</code>, <em>through some magic</em>, the GPU knows exactly what mipmap to use, so that it never skips over texels or displays a too blurry version. We can kinda guess that it has something to do with the viewing angle and viewing distance, but the solution is much more fun. 😉</p>
<h2 id="the-screen-space-derivative">The Screen Space Derivative</h2>
<p>The main part of that magic is actually the <strong>screen space derivative</strong>, a handy and special feature of any modern GPU. Instead of trying to guess the area from any viewing angle or distance, we simply use the screen space derivative to get the <em>rate of change</em> of the UV coordinate, with respect to the screen.</p>
<blockquote>
<blockquote>
<p>In fact, the GPU itself doesn&rsquo;t even have much of a concept of what viewing angle or viewing distance is. The information to calculate this may not even be supplied in the first place. (Think of what should happen to a mesh without normals to calculate a viewing angle.) <strong>By the way</strong> if you have access to this information, check out the <em>Dynamic Dilation</em> section in the white paper of the <a href="https://sluglibrary.com/slug_algorithm.pdf">Slug Font Rendering library</a>. You could use the given formula to calculate the derivatives on a per-vertex level.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>This is also the reason why even a triangle that is just 1x1 pixels large still generates workload for 2x2 pixels. Even for that single pixel, the GPU needs to know the derivatives. This is a problem with highly detailed meshes and commonly known as <em>quad overdraw</em>.</p>
</blockquote>
</blockquote>
<p>While for <code>tex2D()</code> this happens under the hood, since Shader Model 3.0 (in DirectX lingo), you are able to get the derivatives for any variable you want, via the HLSL functions <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-ddx">ddx()</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-ddy">ddy()</a>.</p>
<p>Using <code>ddx(MyUvCoordinate)</code> will give you the rate of change of <code>MyUvCoordinate</code> on the X-axis of the screen and <code>ddy(MyUvCoordinate)</code> for the Y-axis. Getting the screen space derivative for any constant value, let&rsquo;s say <code>ddx(42)</code>, will always give you always 0, as 42 is constant and never changes over the course of the screen.</p>
<p>The following video may give you an idea of how this looks:</p>
 <video controls="controls" loop="true" autoplay>
  <source type="video/mp4" src="uv_derivate_anim.mp4"></source>
  <p>Your browser does not support the video element.</p>
</video>
Note that I'm showing the length/magnitude ("| |") of the derivative in the video for better illustration.
<blockquote>
<p>The fragment shader for the left and middle quad.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>float4 <span style="color:#50fa7b">frag</span>(VertexInput input) <span style="color:#ff79c6">:</span> SV_Target0{
</span></span><span style="display:flex;"><span> <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">length</span>(<span style="color:#50fa7b">ddx</span>(input.uv)); <span style="color:#6272a4">// ddy for middle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div></blockquote>
<h2 id="the-pixel-footprint">The Pixel Footprint</h2>
<p>The screen space derivatives alone don&rsquo;t tell us much, so let&rsquo;s focus on how we get something useful out of them. For better understanding, let&rsquo;s introduce the concept of the <em>pixel footprint</em>.
This refers to the area that an individual pixel <em>sees</em>.</p>

 
 <figure>
 <img
 class="mb-2 mx-auto leading-none shadow-xl"
 src="https://julhe.github.io/posts/always_sharp_sdf_textures/ddxddy.png"
 alt="ddX and ddY, displayed as vectors projected onto a triangle. Anisotropic diameter in yellow. The white square represents a single pixel.">
 <figcaption class="text-sm text-right text-raven-500">
 <p>ddX and ddY, displayed as vectors projected onto a triangle. Anisotropic diameter in yellow. The white square represents a single pixel.</p>
 </figcaption>
 </figure>

<p>We can treat the X and Y screen space derivatives (ddx and ddy) as vectors that span a parallelogram.</p>
<blockquote>
<p>While the pixel footprint is not a parallelogram, it is an approximation that works very well most of the time.</p>
</blockquote>
<p>We can use this fact to calculate the area, diameter and longest side of the pixel footprint. For mipmaps, it is going to be the longest side, for our SDF the diameter, more on that later.</p>
<blockquote>
<p>I don&rsquo;t know <em>why</em> the longest side is used for mip mapping for sure, but I assume that, since it is the most conservative value, even with heavily distorted UVs it wouldn&rsquo;t introduce aliasing.</p>
</blockquote>
<p>Equipped with this knowledge, we can now calculate the mipmap index ourselves.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">float</span> GetMipMapLevel(float2 uv, float2 texel_size) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// convert UV space [0,1] to texel space [0..axis_size].</span>
</span></span><span style="display:flex;"><span>    float2 dx_uv <span style="color:#ff79c6">=</span> ddx(uv) <span style="color:#ff79c6">*</span> texel_size; 
</span></span><span style="display:flex;"><span>    float2 dy_uv <span style="color:#ff79c6">=</span> ddy(uv) <span style="color:#ff79c6">*</span> texel_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// calculate the squared length of the longest axis.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">float</span> longest_side <span style="color:#ff79c6">=</span> max(dot(dx_uv, dx_uv), dot(dy_uv, dy_uv)); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// take the square root of the squared-longest-side and use log2 to get the according mip-map index. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Log2 is used because mip-maps are index by thier base to the power-of-two.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Note that: 0.5 * log2(longest_side) == log2(sqrt(longest_side)) </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0.5</span> <span style="color:#ff79c6">*</span> log2(longest_side); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>You can also look at the reference here: <a href="https://registry.khronos.org/OpenGL/specs/gl/glspec42.core.pdf">the OpenGL 4.2 specifications</a>. Look at equation 3.21. Note that, for some reasons, the formula doesn&rsquo;t take the texture resolution into account. It will not work out of the box when you use it in shader code. This is &ldquo;fixed&rdquo; in the above version. If you know more about why it is like this in the specs, I&rsquo;d be happy to hear!</p>
</blockquote>
<h2 id="filtering-the-sdf">Filtering The SDF</h2>
<p>For the SDF, however, we are not interested in the mip-map level.</p>
<p>Remember, our initial goal was to calculate the distance between two texels after the perspective transformation. Instead of the longest side as for mip-maps we are going to use the diameter of the pixel footprints area this.</p>
<blockquote>
<p>In my tests using the diameter had better sharpening and less aliasing, especially on step viewing angles.</p>
</blockquote>
<p>To calculate the area first, we can use the <em>Jacobian Matrix</em>, a matrix that is built by the partial derivatives, in our case, the screen space derivatives of the UV. In HLSL, it is built as <code>float2x2 uvJacobian = float2x2(ddx(uv), ddy(uv))</code>. If we now calculate the <em>determinant</em>, we get a value that essentially indicates the &ldquo;space distortion&rdquo; of a matrix. In the case of the 2D Jacobian Matrix, this is identical to calculating <a href="https://en.wikipedia.org/wiki/Parallelogram#Area_in_terms_of_Cartesian_coordinates_of_vertices">the area of a parallelogram</a>. Finally, after the taking the square root of the area, we got what we needed.</p>
<p>This animation may help visualize what is happening with the diameter under different viewing conditions.</p>
 <video controls="controls" loop="true" autoplay>
  <source type="video/mp4" src="uvfootprint.mp4"></source>
  <p>Your browser does not support the video element.</p>
</video>
<p>If we multiply the pixel footprint area by the number of texels (the texture resolution), we get the area in texel space that the pixel covers. That means that if this value is 1.0, we have exactly one texel under the pixel. A value larger than 1.0 means more than one texel per pixel, and vice versa.</p>
<p>Putting it together, we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#8be9fd">float</span> <span style="color:#50fa7b">FilterSdfTextureExact</span>(<span style="color:#8be9fd">float</span> sdf, float2 uvCoordinate, float2 textureSize) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Calculate the derivative of the UV coordinate and build the jacobian-matrix from it.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    float2x2 pixelFootprint <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">half2x2</span>(<span style="color:#50fa7b">ddx</span>(uvCoordinate), <span style="color:#50fa7b">ddy</span>(uvCoordinate));
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Calculate the area under the pixel.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Note the use of abs(), because the area may be negative.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">float</span> pixelFootprintDiameterSqr <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">abs</span>(<span style="color:#50fa7b">determinant</span>(pixelFootprint)); 
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Multiply by texture size.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    pixelFootprintDiameterSqr <span style="color:#ff79c6">*=</span> textureSize.x <span style="color:#ff79c6">*</span> textureSize.y ;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Compute the diameter.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">float</span> pixelFootprintDiameter <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">sqrt</span>(pixelFootprintDiameterSqr);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Clamp the filter width to [0, 1] so we won&#39;t overfilter, which fades the texture into grey
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    pixelFootprintDiameter <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">saturate</span>(pixelFootprintDiameter) ; 
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">saturate</span>(<span style="color:#50fa7b">inverseLerp</span>(<span style="color:#ff79c6">-</span>pixelFootprintDiameter, pixelFootprintDiameter, sdf));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="bonus-why-not-just-use-fwidth-directly-for-filtering">Bonus: Why Not Just Use fwidth() Directly For Filtering?</h3>
<p>Some resources may point out the usage of <code>fwidth()</code> directly, as in</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#ff79c6">half</span> SampleSDFMask(texture2D _SDFTexture, float2 uv) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">half</span> sdf_raw <span style="color:#ff79c6">=</span> tex2D(_SDFTexture, i.uv);		<span style="color:#6272a4">// sample</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">half</span> mask_fwidth <span style="color:#ff79c6">=</span> fwidth(mask);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">half</span> mask <span style="color:#ff79c6">=</span> saturate((sdf_raw <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2.0</span> <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1.0</span>) <span style="color:#ff79c6">/</span> mask_fwidth);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> mask; 
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><blockquote>
<p>As a recap, fwidth() is defined as <code>abs(ddx(p)) + abs(ddy(p))</code>.</p>
</blockquote>
<p>So instead of taking the derivative of the UV, we take the sampled SDF value directly.</p>
<p>This is not optimal for two reasons:</p>
<ul>
<li>It will introduce aliasing, since the &ldquo;sharpening value&rdquo; is calculated for 2x2 pixel blocks and not per-pixel.</li>
<li>It creates a hidden dependency between the pixels, because in order to know the value of <code>mask_fwidth</code>, all four pixels need to know the value of <code>mask</code> first.</li>
</ul>
<h3 id="final-code">Final Code</h3>
<script src="https://gist.github.com/julhe/fa278c09ce577711c43296955ffc54a0.js"></script>
<hr>
<h1 id="further-reading">Further Reading</h1>
<ul>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/1111411.1111433">Real-Time Texture-Mapped Vector Glyphs [Qin et al. 2006]</a></li>
</ul>

      </article>
      

      

    </div>
  </div>
</div>
<hr>
<script src="https://utteranc.es/client.js"
        repo="julhe/julhe.github.io"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

  </main>
  <footer class="footer">
  <div class="ax-l-i max-w-6xl">
    <nav class="flex items-center justify-center">
    </nav>
    <div class="footer-social flex items-center justify-center mt-4">
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Twitter" href="https://twitter.com/schneckerstein"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M32 6.078c-1.2.522-2.458.868-3.78 1.036 1.36-.812 2.398-2.088 2.886-3.626a13.11 13.11 0 0 1-4.16 1.588C25.742 3.794 24.026 3 22.154 3a6.56 6.56 0 0 0-6.556 6.562c0 .52.044 1.02.152 1.496-5.454-.266-10.28-2.88-13.522-6.862-.566.982-.898 2.106-.898 3.316a6.57 6.57 0 0 0 2.914 5.452 6.48 6.48 0 0 1-2.964-.808v.072c0 3.188 2.274 5.836 5.256 6.446-.534.146-1.116.216-1.72.216-.42 0-.844-.024-1.242-.112.85 2.598 3.262 4.508 6.13 4.57a13.18 13.18 0 0 1-8.134 2.798c-.538 0-1.054-.024-1.57-.1C2.906 27.93 6.35 29 10.064 29c12.072 0 18.672-10 18.672-18.668 0-.3-.01-.57-.024-.848C30.014 8.56 31.108 7.406 32 6.078z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="Github" href="https://github.com/julhe"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M15.998 0C7.164 0 0 7.35 0 16.417 0 23.67 4.584 29.82 10.944 31.994c.8.15 1.092-.356 1.092-.79l-.022-2.792c-4.45.99-5.4-2.202-5.4-2.202-.726-1.896-1.776-2.4-1.776-2.4-1.454-1.018.108-.998.108-.998 1.606.117 2.45 1.693 2.45 1.693 1.428 2.507 3.746 1.784 4.658 1.363.144-1.06.558-1.784 1.016-2.195-3.552-.415-7.288-1.823-7.288-8.113 0-1.792.624-3.258 1.648-4.406-.166-.415-.714-2.085.156-4.344 0 0 1.344-.44 4.4 1.683 1.276-.364 2.644-.546 4.006-.552a14.98 14.98 0 0 1 4.006.554C23.062 6.37 24.404 6.8 24.404 6.8c.872 2.26.324 3.93.16 4.344 1.026 1.148 1.644 2.614 1.644 4.406 0 6.306-3.74 7.694-7.304 8.1.574.507 1.086 1.51 1.086 3.04l-.02 4.503c0 .44.288.95 1.1.788C27.42 29.817 32 23.667 32 16.417 32 7.35 24.836 0 15.998 0z"/></svg></a>
      <a class="block mx-3 w-6 h-6 text-raven-700 hover:text-raven-900" target="_blank" rel="noopener nofollow" title="LinkedIn" href="https://www.linkedin.com/in/julian-heinken-34463327/"><svg class="fill-current" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M29.692 0H2.308A2.31 2.31 0 0 0 0 2.308v27.384A2.31 2.31 0 0 0 2.308 32h27.384A2.31 2.31 0 0 0 32 29.692V2.308A2.31 2.31 0 0 0 29.692 0zM11.35 24.188H7.454V12.464h3.897v11.723zM9.402 10.863h-.025c-1.308 0-2.153-.9-2.153-2.025 0-1.15.872-2.026 2.205-2.026s2.153.875 2.18 2.026c0 1.125-.846 2.025-2.205 2.025zm16 13.324h-3.896v-6.272c0-1.576-.564-2.65-1.974-2.65-1.076 0-1.717.725-2 1.425-.103.25-.128.6-.128.95v6.547h-3.896V12.464h3.896v1.66c.518-.8 1.444-1.935 3.512-1.935 2.564 0 4.486 1.676 4.486 5.276v6.722z"/></svg></a>
    </div>

    <div class="footer-copyright text-sm text-center text-gray-500 mt-4">
      &#169; -2024 Julian Heinken
    </div>
    <div class="text-sm sm:text-xs text-center text-gray-500 mt-2">
      Powered by <a href="https://www.axiomtheme.com/?utm_source=theme-footer&utm_medium=website&utm_campaign=referral">Axiom</a>
    </div>
  </div>
</footer>

<script src="https://julhe.github.io/bundle.js?v=1711549386"></script>


</body>
</html>
